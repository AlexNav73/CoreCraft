using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using CoreCraft.SourceGeneration.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CoreCraft.Generators;

#pragma warning disable

static class Extensions
{
    public static IncrementalValuesProvider<(TKey Key, ImmutableArray<TElement> Right)> GroupBy<TLeft, TRight, TKey, TElement>(
        this IncrementalValuesProvider<(TLeft Left, TRight Right)> source,
        Func<(TLeft Left, TRight Right), TKey> keySelector,
        Func<(TLeft Left, TRight Right), TElement> elementSelector)
        where TLeft : IEquatable<TLeft>
        where TRight : IEquatable<TRight>
        where TKey : IEquatable<TKey>
        where TElement : IEquatable<TElement>
    {
        return source.Collect().SelectMany((item, token) =>
        {
            Dictionary<TKey, ImmutableArray<TElement>.Builder> map = new();

            foreach ((TLeft, TRight) pair in item)
            {
                TKey key = keySelector(pair);
                TElement element = elementSelector(pair);

                if (!map.TryGetValue(key, out ImmutableArray<TElement>.Builder builder))
                {
                    builder = ImmutableArray.CreateBuilder<TElement>();

                    map.Add(key, builder);
                }

                builder.Add(element);
            }

            token.ThrowIfCancellationRequested();

            ImmutableArray<(TKey Key, ImmutableArray<TElement> Elements)>.Builder result =
                ImmutableArray.CreateBuilder<(TKey, ImmutableArray<TElement>)>();

            foreach (KeyValuePair<TKey, ImmutableArray<TElement>.Builder> entry in map)
            {
                result.Add((entry.Key, entry.Value.ToImmutable()));
            }

            return result;
        });
    }
}

public record ClassInfo(string Name, string Namespace, string Visibility);

public record BindingInfo(string EntityTypeName, string EntityPropertyName);

public record PropertyInfo(string Name, BindingInfo Binding);

[Generator(LanguageNames.CSharp)]
public partial class BindingGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor _descriptor = new DiagnosticDescriptor(
#pragma warning disable RS2008 // Enable analyzer release tracking
        id: "BG001",
#pragma warning restore RS2008 // Enable analyzer release tracking
        title: "Exception occurred during generator execution",
        messageFormat: "Message: {0} StackTrace: {1}",
        category: "BG",
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    private const string BindingAttributeName = "CoreCraft.Generators.Bindings.BindingAttribute";

    private const string AttributeCode = """
        
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by the tool.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        #nullable enable
        #pragma warning disable

        namespace CoreCraft.Generators.Bindings
        {
            [global::System.AttributeUsage(System.AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
            public class BindingAttribute(global::System.String TypeName, global::System.String Name)
                : global::System.Attribute
            {
            }
        }

        #pragma warning restore
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "BindingAttribute.g.cs",
            SourceText.From(AttributeCode, Encoding.UTF8)));

        IncrementalValuesProvider<(ClassInfo?, PropertyInfo?)> bindingProperties = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                BindingAttributeName,
                predicate: static (node, _) => node is PropertyDeclarationSyntax { Parent: ClassDeclarationSyntax or RecordDeclarationSyntax, AttributeLists.Count: > 0 },
                transform: static (context, token) => GetPropertyInfo(context, context.TargetNode, context.Attributes, token))
            .Where(static item => item.Item1 is not null && item.Item2 is not null);

        IncrementalValuesProvider<(ClassInfo?, ImmutableArray<PropertyInfo?>)> groupedByClass = bindingProperties
            .GroupBy(static k => k.Left, static v => v.Right);

        context.RegisterSourceOutput(groupedByClass, static (productionContext, sourceContext) => Execute(productionContext, sourceContext.Item1!, sourceContext.Item2));
    }

    // determine the namespace the class/enum/struct is declared in, if any
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string @namespace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
                potentialNamespaceParent is not NamespaceDeclarationSyntax
                && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            @namespace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                @namespace = $"{namespaceParent.Name}.{@namespace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return @namespace;
    }

    public static string GetClassVisibility(BaseTypeDeclarationSyntax node)
    {
        foreach (var modifier in node.Modifiers)
        {
            if (modifier.IsKind(SyntaxKind.PublicKeyword))
            {
                return "public";
            }
            else if (modifier.IsKind(SyntaxKind.InternalKeyword))
            {
                return "internal";
            }
            // Add checks for other visibility modifiers (protected, private)
        }

        // No visibility modifier explicitly defined, so it's internal
        return "internal";
    }

    private static string GetNamespace(INamespaceSymbol namespaceSymbol)
    {
        var @namespace = string.Empty;

        while (!namespaceSymbol.IsGlobalNamespace && namespaceSymbol.ContainingNamespace != null)
        {
            @namespace = $"{namespaceSymbol.ContainingNamespace.Name}.{@namespace}";
        }

        return @namespace;
    }

    private static (ClassInfo?, PropertyInfo?) GetPropertyInfo(GeneratorAttributeSyntaxContext context, SyntaxNode syntaxNode, ImmutableArray<AttributeData> attributes, CancellationToken token)
    {
        var propertyDeclarationSyntax = (PropertyDeclarationSyntax)syntaxNode;

        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }

        if (syntaxNode.Parent is not BaseTypeDeclarationSyntax classDeclarationSyntax || attributes.Length != 1)
        {
            return (null, null);
        }

        var attribute = attributes.Single();
        if (attribute.ConstructorArguments.Length != 2)
        {
            return (null, null);
        }

        var entityTypeArgument = attribute.ConstructorArguments[0];
        var propertyNameArgument = attribute.ConstructorArguments[1];

        if (entityTypeArgument is { Kind: not TypedConstantKind.Primitive } || 
            propertyNameArgument is { Kind: not TypedConstantKind.Primitive })
        {
            return (null, null);
        }

        var classInfo = new ClassInfo(
            classDeclarationSyntax.Identifier.ValueText,
            GetNamespace(classDeclarationSyntax),
            GetClassVisibility(classDeclarationSyntax));
        var propertyInfo = new PropertyInfo(
            propertyDeclarationSyntax.Identifier.ValueText,
            new BindingInfo(
                entityTypeArgument.Value as string,
                propertyNameArgument.Value as string));

        return (classInfo, propertyInfo);
    }

    public static void Execute(
        SourceProductionContext context,
        ClassInfo classInfo,
        ImmutableArray<PropertyInfo?> assemblyName)
    {
        try
        {
            ExecuteInternal(context, classInfo, assemblyName);
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(_descriptor, Location.None, ex.Message, ex.StackTrace));
        }
    }

    private static void ExecuteInternal(
        SourceProductionContext context,
        ClassInfo classInfo,
        ImmutableArray<PropertyInfo?> propertyInfos)
    {
        using var writer = new StringWriter();
        using var code = new IndentedTextWriter(writer, "    ");

        code.WriteLine("using CoreCraft.Core;");
        code.WriteLine("using CoreCraft.ChangesTracking;");
        code.WriteLine($"using {classInfo.Namespace}.Model.Entities;");

        code.WriteLine($"namespace {classInfo.Namespace}");
        code.Block(() =>
        {
            var entityTypeName = propertyInfos.Select(x => x.Binding.EntityTypeName).Distinct().Single();

            code.Class(classInfo.Visibility, "partial", classInfo.Name,
                [$"IBinding<{entityTypeName}, {entityTypeName}Properties>"],
                () =>
                {
                    code.WriteLine($"public {classInfo.Name}({entityTypeName} entity)");
                    code.Block(() =>
                    {
                        code.WriteLine($"Entity = entity;");
                    });

                    code.WriteLine($"public {entityTypeName} Entity {{ get; }}");

                    code.WriteLine($"public void Update(IEntityChange<{entityTypeName}, {entityTypeName}Properties> change)");
                    code.Block(() =>
                    {
                        foreach (var property in propertyInfos)
                        {
                            code.WriteLine($"{property.Name} = change.NewData!.{property.Binding.EntityPropertyName};");
                        }
                    });
                });
        });

        AddSourceFile(context, $"{classInfo.Namespace}.{classInfo.Name}", writer.ToString());
    }

    private static void AddSourceFile(SourceProductionContext context, string fileName, string content)
    {
        context.AddSource($"{fileName}.g.cs", SourceText.From(content, Encoding.UTF8));
    }
}

#pragma warning restore
